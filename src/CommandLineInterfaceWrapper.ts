/** structural typedefs */
declare interface Exec {
    exec(command: string, callback: Function): void;
}
declare interface Require {
    (module: string): any;
}
declare const require: Require;
declare interface ProxyHandler {
    get (target: object, name: string): any;
    set (object: object, property: string, value: any): any;
}
declare interface Proxy extends CommandLineInterfaceWrapper {
    new (object: object, handler: ProxyHandler): any;
}
declare const Proxy: Proxy;
declare interface IoCallback {
    (error: string, stdout: string, stderr: string): void;
}
/** end structural typedefs */

const child_process: Exec = require('child_process');

/**
 *
 * @module
 *
 * The CLIWrapper or "CLIW" class wraps any command line executable in a NodeJS class.
 *
 * @example
 *
 * const CommandLineInterfaceWrapper = require('cli-to-node');
 *
 * const echo = new CommandLineInterfaceWrapper('echo');
 * echo('hello, world').then(...); // Promise
 *
 * @example
 *
 * const du = new CommandLineInterfaceWrapper('du');
 *
 * // call directly:
 * du('-sh', './src/*').then(...);
 *
 * // call arbitrary method representing cli arguments:
 * du['-sh']('./src/*').then(...);
 *
 */
export default class CommandLineInterfaceWrapper {

    /**
     * The main command to be represented by this instance e.g.
     * du
     * echo
     * sh
     * npm
     * git
     * ...
     */
    public command: string = '';

    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy
     */
    public proxy: Proxy;

    /**
     * Prepended to io buffer entries.
     */
    public prefix: string = '';

    /**
     * Any stdout or stderr generated by this instance will be entered here.
     */
    public ioBuffer: string[] = null;

    /**
     * @note Copy-construction enabled.
     * @param command can be any CLI command.
     * @param [prefix] to be prepended to the ioBuffer log.
     * @returns {Proxy}
     */
    public constructor(command: string|CommandLineInterfaceWrapper, prefix: string = '') {

        if (command instanceof CommandLineInterfaceWrapper) {
            return this.copyConstructor(command);
        }

        if (!prefix) {
            prefix = command + ': ';
        }

        this.command = command;
        this.prefix = prefix;
        const ioBuffer: string[] = this.ioBuffer = (this.ioBuffer || []);

        const callable = function (...argv: string[]) {
            return this.dispatchCommand(ioBuffer, command, ...argv);
        }.bind(this);

        Object.setPrototypeOf(callable, CommandLineInterfaceWrapper.prototype);

        this.proxy = new Proxy(callable, this.handler());
        return this.proxy;

    }

    /**
     * Invoking any method on a CommandLineInterfaceWrapper instance will result in
     * the base command being dispatched with the method name as its first argument.
     *
     * Any number of arguments to the method will be appended as additional CLI arguments.
     *
     * @param {...string} argv any number of command line arguments.
     */
    public ['__any_command__'](...argv: string[]): string {
        // shell exec this.command + argv
        return '__the_stdout_of_that_command__';
    }

    /**
     * Immediately console log everything from the ioBuffer and empty it.
     * @param [ioBuffer]
     */
    public flush(ioBuffer: string[] = this.ioBuffer): void {
        for (let i: number = 0; i < ioBuffer.length; ++i) {
            console.log(ioBuffer[i]);
        }
        ioBuffer.length = 0;
    }

    /**
     * @param [ioBuffer]
     * @param resolve
     * @param reject
     * @returns {IoCallback} by default, returns a callback to be used with child_process.exec
     *                       which will store the error and stdout returned in the designated ioBuffer.
     */
    private ioCallback(ioBuffer: string[] = this.ioBuffer,
                       resolve: Function,
                       reject: Function): IoCallback {

        const prefix = this.prefix;

        return <IoCallback>function (error: string, stdout: string, stderr: string) {

            error = error || '';
            stderr = stderr || '';
            stdout = stdout || '';

            const error_: string[] = error.split('\n').filter(Boolean);
            const stderr_: string[] = stderr.split('\n').filter(Boolean);
            const stdout_: string[] = stdout.split('\n').filter(Boolean);

            if (error) {
                ioBuffer.push(error_.map(_ => prefix + _).join('\n'));
                reject(ioBuffer);
            }
            if (stderr) {
                ioBuffer.push(stderr_.map(_ => prefix + _).join('\n'));
            }
            if (stdout) {
                ioBuffer.push(stdout_.map(_ => prefix + _).join('\n'));
            }
            resolve(ioBuffer);
        }

    }

    /**
     * @param [ioBuffer] the storage array for the output of the dispatched command.
     * @param argv any number of additional command line arguments.
     * @returns {Promise<string[]>} a Promise that will resolve with the cli output.
     */
    private dispatchCommand(ioBuffer: string[] = this.ioBuffer,
                            ...argv: string[]): Promise<string[]> {

        return new Promise((resolve, reject) => {
            child_process.exec(argv.join(' '), this.ioCallback(ioBuffer, resolve, reject));
        });

    }

    /**
     * @returns {ProxyHandler} A property access capture mode that ensures all method calls are translated
     *                         to CLI commands.
     */
    private handler(): ProxyHandler {

        const { command, ioBuffer } = this;

        return <ProxyHandler>{
            get: (target: object, name: string): Function => {
                return (...argv: string[]): Promise<any> => {
                    return this.dispatchCommand(ioBuffer, command, name, ...argv);
                };
            },
            set: function (object: object, property: string, value: any): any {
                return true;
            }
        }

    }

    // # the following methods are pointless:

    /**
     * @param other
     * @returns {CommandLineInterfaceWrapper} a copy of the other CLIW.
     */
    public copyConstructor(other: CommandLineInterfaceWrapper): CommandLineInterfaceWrapper {

        this.command = other.command;
        this.prefix = other.prefix;
        this.ioBuffer = other.ioBuffer.slice();
        this.constructor(this.command);

        return this;

    }

    /**
     * Move another instance into this one.
     * @param other
     * @returns {CommandLineInterfaceWrapper}
     */
    public moveConstructor(other: CommandLineInterfaceWrapper): CommandLineInterfaceWrapper {

        this.command = other.command;
        delete other.command;

        this.prefix = other.prefix;
        delete other.prefix;

        this.ioBuffer = other.ioBuffer;
        delete other.ioBuffer;

        this.proxy = other.proxy;
        delete other.proxy;

        return this;

    }

    /**
     * Deletes all properties of this instance.
     */
    public destructor(): void {
        new CommandLineInterfaceWrapper('').moveConstructor(this);
    }

};
